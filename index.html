<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Data of Legends : A detailed look into League of Legends data.">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
    <script src="javascripts/brython.js"></script>
    <title>Data of Legends</title>
  </head>

  <body onload="brython()">
  <script type="text/python">
  from browser import document, alert

  import json
  import requests
  import pandas as pd
  import numpy as np
  import matplotlib.pyplot as plt
  import time
  import pickle
  import seaborn as sns
  import sklearn.cross_validation
  import scipy.stats as stats
  from sklearn.cross_validation import cross_val_score
  from sklearn.ensemble import RandomForestClassifier

  """
  Finds all possible combinations of pairs/triples for each team in each match
  Input:
      team1: column names for team 1
      team2: column names for team 2
  Output:
      data: dataframe of combinations
  """
  def create_pairs(matches):
      team1 = ['top1', 'jun1', 'mid1', 'adc1', 'sup1']
      team2 = ['top2', 'jun2', 'mid2', 'adc2', 'sup2']
      title = ['champ1', 'champ2', 'W', 'ID']
      # number of matches in data set
      rows = []
      print 'Processing Team 1 Pairs'
      for p in range(0, len(matches)): 
          for i in range(0,len(team1)):
              for j in range(i+1, len(team1)):
                  row = []
                  row.append(sorted([matches[team1[i]][p], matches[team1[j]][p]])[0])
                  row.append(sorted([matches[team1[i]][p], matches[team1[j]][p]])[1])
                  row.append(matches['Winner'][p] == 1)
                  row.append(team1[i]+team1[j])
                  rows.append(row)
          if (p % 5000 == 0):
              print str(p+1) + ' matches processed...'
      print 'Processing Team 2 Pairs'
      for p in range(0, len(matches['top1'])): 
          for i in range(0,len(team2)):
              for j in range(i+1, len(team2)):
                  row = []
                  row.append(sorted([matches[team2[i]][p], matches[team2[j]][p]])[0])
                  row.append(sorted([matches[team2[i]][p], matches[team2[j]][p]])[1])
                  row.append(matches['Winner'][p] == 0)
                  row.append(team2[i]+team2[j])
                  rows.append(row)
          if (p % 5000 == 0):
              print str(p+1) + ' matches processed...'
      data = pd.DataFrame(rows,columns=title)
      return data

  def create_trips(matches):
      team1 = ['top1', 'jun1', 'mid1', 'adc1', 'sup1']
      team2 = ['top2', 'jun2', 'mid2', 'adc2', 'sup2']
      title = ['champ1','champ2','champ3','W','ID']
      num = len(matches)
      data = pd.DataFrame(index=range(0, 20*num), columns=title)
      champ1_list = []
      champ2_list = []
      champ3_list = []
      win = []
      ids = []
      for p in range(0, len(matches['top1'])): 
          for i in range(0,len(team1)):
              for j in range(i+1, len(team1)):
                  for k in range(j+1, len(team1)):
                      temp = sorted([matches[team1[i]][p], matches[team1[j]][p], matches[team1[k]][p]])
                      champ1_list.append(temp[0])
                      champ2_list.append(temp[1])
                      champ3_list.append(temp[2])
                      win.append(matches['Winner'][p] == 1)
                      ids.append(team1[i]+team1[j]+team1[k])
          if (p % 5000 == 0):
              print str(p+1) + ' matches processed...'
      for p in range(0, len(matches['top1'])): 
          for i in range(0,len(team2)):
              for j in range(i+1, len(team2)):
                  for k in range(j+1, len(team2)):
                      temp = sorted([matches[team2[i]][p], matches[team2[j]][p], matches[team2[k]][p]])
                      champ1_list.append(temp[0])
                      champ2_list.append(temp[1])
                      champ3_list.append(temp[2])
                      win.append(matches['Winner'][p] == 0)
                      ids.append(team2[i]+team2[j]+team2[k])
          if (p % 5000 == 0):
              print str(p+1) + ' matches processed...'
      data['champ1'] = champ1_list
      data['champ2'] = champ2_list
      data['champ3'] = champ3_list
      data['W'] = win
      data['ID'] = ids
      return data


  # define function to calculate historical win percentage of each pair
  """
  Creates a lookup table that determines the win percentage of each pair/triples of champions
  Input
      champ_pairs: output from create_pairs/create_trips
      cutoff: 
  Output
      data: the lookup table
  """
  def pair_winpercent(champ_pairs, cutoff=0):
      pairlist = pd.DataFrame(champ_pairs)
      pairlist = pairlist.drop_duplicates(subset=['champ1', 'champ2']).reset_index(drop=True)
      pairlist['Wins'] = ''
      pairlist['Matches'] = ''
      pairlist['Win_percent'] = ''
      for i in range(0, len(pairlist)):
          if (i % 4000 == 0):
              print str(i) + ' unique pairs processed'
          filteredlist = champ_pairs[(champ_pairs['champ1'] == pairlist['champ1'][i]) & (champ_pairs['champ2'] == pairlist['champ2'][i])]
          pairlist['Wins'][i] = len(filteredlist[filteredlist['W'] == True])
          pairlist['Matches'][i] = len(filteredlist)
          pairlist['Win_percent'][i] = np.round(1.0*pairlist['Wins'][i]/pairlist['Matches'][i], 2)
      pairlist = pairlist.drop('W', 1).drop('ID', 1).sort(columns='champ2').sort(columns='champ1').reset_index(drop=True)
      return pairlist[pairlist['Matches'] >= cutoff].reset_index(drop=True)

  def triple_winpercent(champ_triples, cutoff=0):
      triplelist = pd.DataFrame(champ_triples)
      triplelist = triplelist.drop_duplicates(subset=['champ1', 'champ2', 'champ3']).reset_index(drop=True)
      triplelist['Wins'] = ''
      triplelist['Matches'] = ''
      triplelist['Win_percent'] = ''
      for i in range(0, len(triplelist)):
          if (i % 4000 == 0):
              print str(i) + ' unique triples processed'
          filteredlist = champ_triples[(champ_triples['champ1'] == triplelist['champ1'][i]) & (champ_triples['champ2'] == triplelist['champ2'][i]) & (champ_triples['champ3'] == triplelist['champ3'][i])]
          triplelist['Wins'][i] = len(filteredlist[filteredlist['W'] == True])
          triplelist['Matches'][i] = len(filteredlist)
          triplelist['Win_percent'][i] = np.round(1.0*triplelist['Wins'][i]/triplelist['Matches'][i], 2)
      triplelist = triplelist.drop('W', 1).drop('ID', 1).sort(columns='champ3').sort(columns='champ2').sort(columns='champ1').reset_index(drop=True)
      return triplelist[triplelist['Matches'] >= cutoff].reset_index(drop=True)



  """

  Input
      champ_pairs: create_pairs output
      pairlist: lookup table
      final_comb: list of column names
      num: number of matches
  Output
      pos_comb: table of probabilities for each game
  """
  def create_prob(champ_pairs, pairlist, final_comb, num):
      count_x = 0
      count_y = 0
      pos_comb = pd.DataFrame(index=range(0,num), columns=final_comb)
      for i in range(0, len(final_comb)):
          if (i % 5 == 0):
              print str(i) + ' fields processed'
          filtered = champ_pairs[champ_pairs['ID'] == final_comb[i]].reset_index(drop=True)  
          array = []
          for j in range(0, len(filtered)):
              temp = pairlist[(pairlist['champ1'] == filtered['champ1'][j]) & (pairlist['champ2'] == filtered['champ2'][j])].reset_index(drop=True)['Win_percent']
              if (len(temp) > 0):
                  array.append(temp[0])
                  count_x += 1
                  count_y += 1
              else:
                  array.append(0.5)
                  count_y += 1
          pos_comb[final_comb[i]] = array
      return pos_comb


  def create_prob_full(champ_pairs, champ_triples, pairlist, triplelist, final_comb, num):
      count_x = 0
      count_y = 0
      pos_comb = pd.DataFrame(index=range(0,num), columns=final_comb)
      for i in range(0, len(final_comb)):
          if (i % 5 == 0):
              print str(i) + ' fields processed'
          if (len(final_comb[i]) == 8):
              filtered = champ_pairs[champ_pairs['ID'] == final_comb[i]].reset_index(drop=True)
          else:
              filtered = champ_triples[champ_triples['ID'] == final_comb[i]].reset_index(drop=True)
          array = []
          for j in range(0, len(filtered)):
              if (len(final_comb[i]) == 8):
                  temp = pairlist[(pairlist['champ1'] == filtered['champ1'][j]) & (pairlist['champ2'] == filtered['champ2'][j])].reset_index(drop=True)['Win_percent']
              else:
                  temp = triplelist[(triplelist['champ1'] == filtered['champ1'][j]) & (triplelist['champ2'] == filtered['champ2'][j]) & (triplelist['champ3'] == filtered['champ3'][j])].reset_index(drop=True)['Win_percent']
              if (len(temp) > 0):
                  array.append(temp[0])
                  count_x += 1
                  count_y += 1
              else:
                  array.append(0.5)
                  count_y += 1               
          pos_comb[final_comb[i]] = array
      return pos_comb

  api_key = 'c977fbae-0c60-4d6c-a3dc-ee1b305dbdd7'
  train = pickle.load(open('train.pckl', 'rb'))
  lookup_table2 = pickle.load(open('lookuptable2.pckl', 'rb'))
  position_pairs = pickle.load(open('position_pairs.pckl', 'rb'))
  train_reduced = pickle.load(open('train_reduced.pckl', 'rb'))
  trim_lookup2 = lookup_table2[lookup_table2['Matches'] >= 5].reset_index(drop=True)
  X = train_reduced.as_matrix()
  Y = np.array(train['Winner']) 
  forest_train = RandomForestClassifier(n_estimators=18).fit(X, Y)
  categ = ['top1', 'jun1', 'mid1', 'adc1', 'sup1', 'top2', 'jun2', 'mid2', 'adc2', 'sup2', 'Winner']
  alert("Setup completed!")
  </script>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/georgewu2/cs109-project">View on GitHub</a>

          <h1 id="project_title">Data of Legends</h1>
          <h2 id="project_tagline">A detailed look into League of Legends data.</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/georgewu2/cs109-project/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/georgewu2/cs109-project/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>
<a id="video" class="anchor" href="#video" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Video</h3>

<p>VIDEO GOES HERE</p>

<h3>
<a id="motivation" class="anchor" href="#motivation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Background and Motivation</h3>

<h6>What is League of Legends?</h6>

<p>From Wikipedia:</p>

<p class="quote">
  League of Legends (LoL) is a multiplayer online battle arena video game developed and published by Riot Games. As of January 2014, over 67 million people play League of Legends per month, 27 million per day, and over 7.5 million concurrently during peak hours. League of Legends has spawned a large, active competitive scene. In North America and Europe, Riot Games organizes the League of Legends Championship Series, which consists of 8 professional teams in each continent.
</p> 

<h6>Gameplay</h6>
<p>
  There are two teams, with five players on each team. Each player controls a unique <strong>champion</strong> that has its own unique abilities. Each team has a base, one at the bottom left corner of the map and one at the top right corner of the map. There are three <strong>lanes</strong> that <strong>minions</strong> from each team pass through, labeled <strong>Top</strong>, <strong>Middle</strong>, and <strong>Bottom</strong>. In between these three lanes is the <strong>jungle</strong> where there exists <strong>neutral</strong> monsters. Throughout the lanes and the bases, there are friendly and hostile <strong>turrets</strong> and <strong>inhibitors</strong> in the bases. The objective of the game is to destroy the enemy <strong>nexus</strong> in their base, which is protected by these buildings.
</p>

<p>
  In addition to normal games, Riot provdes a tier system in which players can play ranked games. The skill tiers are <strong>Bronze</strong>, <strong>Silver</strong>, <strong>Gold</strong>, <strong>Platinum</strong>, <strong>Diamond</strong>, <strong>Master</strong>, and <strong>Challenger</strong>. In the higher tiers, the norm is to have a team composition that consists of the following
  <ol type="1">
    <li>Top Laner</li>
    <li>Jungler</li>
    <li>Mid Laner</li>
    <li>Attack Damage Carry</li>
    <li>Support</li>
  </ol>
</p>

<h3>
<a id="problem-data-collection" class="anchor" href="#problem-data-collection" aria-hidden="true"><span class="octicon octicon-link"></span></a>Problem and Data Collection</h3>

<h6>Objectives</h6>

<p>
  With the gameplay in mind, we wanted to explore the following:
  <ol type="1">
    <li>Explore the <strong>challenger</strong> tier dataset and find interesting results.</li>
    <li>Try to predict outcomes of games by training on data and testing on other data.</li>
    <li>Try to predict team gold differential based on team compositions.</li>
  </ol>
</p>

<h6>Data Collection</h6>

<p>
  To perform the analysis, we needed to get data first. What we wanted was all the data from high level matches. Unforunately, Riot's API is more suited for looking up a specific player's data, and not all the matches in a specific tier.
</p>

<p>
  Luckily, there was still a way to get the data that we wanted. We were able to retrieve a list of players in the challenger tier (there are 200 of them), and for each player in the challenger tier, we retrieved a list of match IDs. We combined all the lists into a set and removed duplicates and filtered out only the relevant matches. Since the game will have changes every year, we decided to focus only on the 2014 season. The last problem was that we were rate limited by the API to 10 requests every 10 seconds. Thus, in order to retrieve the data, we had different computers run the retrieval on different portions of the dataset, and then we stored the data into a file so that we did not have to poll Riot's API again.
</p>

<p>Below is am example of the dataframe that contains each player in the challenger tier.</p>
<img src="images/summoner_df.png"></img>

<p>
  After retrieving the data, we found that some of the matches were inconsistent with our assumptions. A few of the matches contained multiple junglers on a single team, and a few of the matches contained no mid laners. We filtered out these matches because in actual professional play, these unorthodox compositions never happen.
</p>

<p>Below is an example of the dataframe that contains each match.</p>
<img src="images/matches_df.png"></img>

<h3>
<a id="data-analysis" class="anchor" href="#data-analysis" aria-hidden="true"><span class="octicon octicon-link"></span></a>Data Analysis</h3>


<h6>Team Synergies</h6>

<p>

</p>

<h6>Lane Matchups</h6>

<h6>Interesting Statistics</h6>

<a id="predicting" class="anchor" href="#prediction" aria-hidden="true"><span class="octicon octicon-link"></span></a>Predicting Game Outcomes</h3>

<h6>glub</h6>

</section>
</div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Data of Legends maintained by <a href="https://github.com/georgewu2">georgewu2</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
